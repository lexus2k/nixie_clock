/* Hello World Example

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_spi_flash.h"

#include "driver/i2c.h"

static uint8_t s_i2c_addr = 0b1101000; //0b1100000; // 0b1100000
static int8_t s_bus_id;

static i2c_cmd_handle_t s_cmd_handle;

static void platform_i2c_start(void)
{
    // ... Open i2c channel for your device with specific s_i2c_addr
    s_cmd_handle = i2c_cmd_link_create();
    i2c_master_start(s_cmd_handle);
    i2c_master_write_byte(s_cmd_handle, ( s_i2c_addr << 1 ) | I2C_MASTER_WRITE, 0x1);
}

static void platform_i2c_stop(void)
{
    // ... Complete i2c communication
    i2c_master_stop(s_cmd_handle);
    /*esp_err_t ret =*/ i2c_master_cmd_begin(s_bus_id, s_cmd_handle, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(s_cmd_handle);
}

static void platform_i2c_send(uint8_t data)
{
    // ... Send byte to i2c communication channel
    i2c_master_write_byte(s_cmd_handle, data, 0x1);
}

static void platform_i2c_close(void)
{
    // ... free all i2c resources here
    i2c_driver_delete(s_bus_id);
}

static void platform_i2c_send_buffer(const uint8_t *data, uint16_t len)
{
    // ... Send len bytes to i2c communication channel here
    while (len--)
    {
        platform_i2c_send(*data);
        data++;
    }
//    i2c_master_write(cmd, data_wr, size, ACK_CHECK_EN);
}

void ssd1306_platform_i2cInit(int8_t busId, uint8_t addr, int8_t arg)
{
    if (addr) s_i2c_addr = addr;
    // init your interface here
    if ( busId < 0) busId = I2C_NUM_1;
    s_bus_id = busId;
    i2c_config_t conf;
    conf.mode = I2C_MODE_MASTER;
    conf.sda_io_num = 21; // I2C_EXAMPLE_MASTER_SDA_IO;
    conf.sda_pullup_en = GPIO_PULLUP_ENABLE;
    conf.scl_io_num = 22; // I2C_EXAMPLE_MASTER_SCL_IO;
    conf.scl_pullup_en = GPIO_PULLUP_ENABLE;
    conf.master.clk_speed = 100000; //I2C_EXAMPLE_MASTER_FREQ_HZ;
    i2c_param_config(s_bus_id, &conf);
    i2c_driver_install(s_bus_id, conf.mode, 0, 0, 0);
//                       I2C_EXAMPLE_MASTER_RX_BUF_DISABLE,
//                       I2C_EXAMPLE_MASTER_TX_BUF_DISABLE, 0);
}



// Turn the LEDs on or off. LEDs is a 16-bit int corresponding to OUT0 (LSB) to OUT15 (MSB)
void setLEDs(int LEDs)
{
    int registerVal=0;
    int registerIncrement = 0b11;
    // Write the value to the LEDs
    platform_i2c_start();
    // Write to consecutive registers, starting with LEDOUT0
    platform_i2c_send(0x80 + 0x14);
    // Write the value for LEDs
    for (int i=0; i< 16; i++)
    {
        if (LEDs & 0x01)
            registerVal += registerIncrement;
        // Move to the next LED
        LEDs >>= 1;
        // Are 4 LED values in the register now?
        if (registerIncrement == 0b11000000)
        {
            // The register can be written out now
            platform_i2c_send(registerVal);
            registerVal = 0;
            registerIncrement = 0b11;
        }
        else
        {
            // Move to the next increment
            registerIncrement <<= 2;
        }
    }
    platform_i2c_stop();
}

// Set the brightness from 0 to 0xFF
void setBrightness(int brightness)
{
    platform_i2c_start();
    // Write to the GRPPWM register
    platform_i2c_send(0x12);
    platform_i2c_send(brightness);
    platform_i2c_stop();
}

void setLedBrightness(int led, int brightness)
{
    platform_i2c_start();
    // Write to the GRPPWM register
    platform_i2c_send(0x02 + led);
    platform_i2c_send(brightness);
    platform_i2c_stop();
}


void app_main()
{
    printf("I2C Init Waiting!\n");
    ssd1306_platform_i2cInit(-1, 0, 0);

    vTaskDelay(1000 / portTICK_PERIOD_MS);
    printf("I2C Init Working!\n");

    platform_i2c_start();
    platform_i2c_send(0x80); // autoincrement
    platform_i2c_send(0x01);
    platform_i2c_send(0x00);
    for(int j=0; j<16; j++)
    {
        platform_i2c_send(0xFF);
    }
    platform_i2c_send(0xFF); // group
    platform_i2c_send(0x0); // not blinking
    for(int j=0; j<4; j++)
    {
        platform_i2c_send(0x0);
    }
    platform_i2c_stop();
    vTaskDelay(100 / portTICK_PERIOD_MS);

    vTaskDelay(1000 / portTICK_PERIOD_MS);

    int r = 0b01001001;
    for(int j=0; j<3; j++)
    {
        printf("I2C!\n");
        setLEDs( r );
        vTaskDelay(1000 / portTICK_PERIOD_MS);
        setLedBrightness(0, 64);
        setLedBrightness(1, 64);
        setLedBrightness(2, 64);
        r <<= 1;
    }

/*    for(int j=0; j<10; j++)
    {
    printf("I2C!\n");
    platform_i2c_start();
    platform_i2c_send(0x14);
    platform_i2c_send(0b01010101);
    platform_i2c_stop();
    platform_i2c_start();
    platform_i2c_send(0x15);
    platform_i2c_send(0b01010101);
    platform_i2c_stop();
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    }*/


    /* Print chip information */
    esp_chip_info_t chip_info;
    esp_chip_info(&chip_info);
    printf("This is ESP32 chip with %d CPU cores, WiFi%s%s, ",
            chip_info.cores,
            (chip_info.features & CHIP_FEATURE_BT) ? "/BT" : "",
            (chip_info.features & CHIP_FEATURE_BLE) ? "/BLE" : "");

    printf("silicon revision %d, ", chip_info.revision);

    printf("%dMB %s flash\n", spi_flash_get_chip_size() / (1024 * 1024),
            (chip_info.features & CHIP_FEATURE_EMB_FLASH) ? "embedded" : "external");

    for (int i = 2; i >= 0; i--) {
        printf("Restarting in %d seconds...\n", i);
        vTaskDelay(1000 / portTICK_PERIOD_MS);
    }
    printf("Restarting now.\n");
    fflush(stdout);
    esp_restart();
}
